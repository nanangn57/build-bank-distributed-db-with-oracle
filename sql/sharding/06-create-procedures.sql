-- Create Stored Procedures for Bank Transactions
-- Run as bank_app user
-- Includes cross-shard transaction handling

PROMPT ====================================
PROMPT Creating Transaction Procedures
PROMPT ====================================

CONNECT bank_app/BankAppPass123@FREEPDB1

-- Function to determine which shard a user_id belongs to based on ID range
CREATE OR REPLACE FUNCTION get_user_shard(p_user_id NUMBER) RETURN VARCHAR2 AS
BEGIN
    CASE
        WHEN p_user_id >= 1 AND p_user_id <= 10000000 THEN
            RETURN 'SHARD1';  -- NA region: Shard 1
        WHEN p_user_id >= 10000001 AND p_user_id <= 20000000 THEN
            RETURN 'SHARD2';  -- EU region: Shard 2
        WHEN p_user_id >= 20000001 AND p_user_id <= 30000000 THEN
            RETURN 'SHARD3';  -- APAC region: Shard 3
        ELSE
            RETURN 'UNKNOWN';
    END CASE;
END;
/

-- Procedure for creating a new user (user_id auto-generated based on region)
-- Routing: user_id determines shard location (NA→Shard1, EU→Shard2, APAC→Shard3)
CREATE OR REPLACE PROCEDURE create_user(
    p_username VARCHAR2,
    p_email VARCHAR2,
    p_full_name VARCHAR2 DEFAULT NULL,
    p_phone VARCHAR2 DEFAULT NULL,
    p_address VARCHAR2 DEFAULT NULL,
    p_region VARCHAR2
) AS
    v_user_id NUMBER;
    v_shard VARCHAR2(50);
BEGIN
    -- Validate region
    IF UPPER(p_region) NOT IN ('NA', 'EU', 'APAC') THEN
        RAISE_APPLICATION_ERROR(-20001, 'Invalid region: ' || p_region || '. Must be NA, EU, or APAC');
    END IF;
    
    -- Insert user (user_id will be auto-generated by trigger based on region)
    -- The trigger uses region-specific sequences to generate IDs in correct ranges:
    --   NA:   1 - 10,000,000      → Shard 1
    --   EU:   10,000,001 - 20,000,000  → Shard 2
    --   APAC: 20,000,001 - 30,000,000  → Shard 3
    INSERT INTO users (username, email, full_name, phone, address, region)
    VALUES (p_username, p_email, p_full_name, p_phone, p_address, UPPER(p_region))
    RETURNING user_id INTO v_user_id;
    
    -- Determine shard based on generated user_id
    v_shard := get_user_shard(v_user_id);
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('User created successfully');
    DBMS_OUTPUT.PUT_LINE('Username: ' || p_username);
    DBMS_OUTPUT.PUT_LINE('User ID: ' || v_user_id || ' (Region: ' || UPPER(p_region) || ', Shard: ' || v_shard || ')');
    
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Username or email already exists');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Procedure for creating an account (account_id and account_number auto-generated, sharded with user via user_id)
-- Routing: Account is co-located with user on same shard (routing follows user_id)
CREATE OR REPLACE PROCEDURE create_account(
    p_user_id NUMBER,
    p_account_type VARCHAR2,
    p_balance NUMBER DEFAULT 0,
    p_currency VARCHAR2 DEFAULT 'USD',
    p_account_number VARCHAR2 DEFAULT NULL  -- Optional: if provided, will be used; otherwise auto-generated
) AS
    v_user_region VARCHAR2(50);
    v_account_id NUMBER;
    v_account_number VARCHAR2(20);
    v_shard VARCHAR2(50);
BEGIN
    -- Get user's region to determine account region and shard location
    -- Accounts are co-located with users (same shard as user based on user_id)
    SELECT region INTO v_user_region
    FROM users
    WHERE user_id = p_user_id;
    
    IF v_user_region IS NULL THEN
        RAISE_APPLICATION_ERROR(-20001, 'User not found: ' || p_user_id);
    END IF;
    
    -- Determine shard based on user_id (accounts follow user's shard)
    v_shard := get_user_shard(p_user_id);
    
    -- Insert account (account_id and account_number will be auto-generated by trigger if not provided, region matches user)
    -- Account is automatically routed to same shard as user (co-location rule)
    INSERT INTO accounts (user_id, account_number, account_type, balance, currency, region)
    VALUES (p_user_id, p_account_number, p_account_type, p_balance, p_currency, v_user_region)
    RETURNING account_id, account_number INTO v_account_id, v_account_number;
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Account created successfully');
    DBMS_OUTPUT.PUT_LINE('Account Number: ' || v_account_number || ' (auto-generated)');
    DBMS_OUTPUT.PUT_LINE('Account ID: ' || v_account_id || ' (Region: ' || v_user_region || ', Shard: ' || v_shard || ')');
    DBMS_OUTPUT.PUT_LINE('Note: Account co-located with user on same shard via user_id');
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'User not found: ' || p_user_id);
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Procedure for transferring money between accounts
-- Automatically handles same-shard and cross-shard transfers
CREATE OR REPLACE PROCEDURE transfer_money(
    p_from_account_id NUMBER,
    p_to_account_id NUMBER,
    p_amount NUMBER,
    p_description VARCHAR2 DEFAULT NULL
) AS
    v_from_balance NUMBER;
    v_from_status VARCHAR2(10);
    v_to_status VARCHAR2(10);
BEGIN
    -- Check and lock from account (automatically routed to correct shard)
    SELECT balance, status INTO v_from_balance, v_from_status
    FROM accounts 
    WHERE account_id = p_from_account_id 
    FOR UPDATE;
    
    -- Validate account status
    IF v_from_status != 'ACTIVE' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Source account is not active');
    END IF;
    
    -- Validate sufficient balance
    IF v_from_balance < p_amount THEN
        RAISE_APPLICATION_ERROR(-20002, 'Insufficient balance. Current balance: ' || v_from_balance);
    END IF;
    
    -- Check destination account exists and is active
    SELECT status INTO v_to_status
    FROM accounts
    WHERE account_id = p_to_account_id;
    
    IF v_to_status != 'ACTIVE' THEN
        RAISE_APPLICATION_ERROR(-20003, 'Destination account is not active');
    END IF;
    
    -- Deduct from source account (automatically routed to correct shard)
    UPDATE accounts 
    SET balance = balance - p_amount, 
        last_updated = SYSDATE 
    WHERE account_id = p_from_account_id;
    
    -- Add to destination account (automatically routed to correct shard)
    -- Oracle Sharding handles cross-shard transactions automatically
    UPDATE accounts 
    SET balance = balance + p_amount, 
        last_updated = SYSDATE 
    WHERE account_id = p_to_account_id;
    
    -- Create transaction record (on source account shard)
    INSERT INTO transactions (
        from_account_id,
        to_account_id,
        transaction_type,
        amount,
        status,
        description
    )
    VALUES (
        p_from_account_id,
        p_to_account_id,
        'TRANSFER',
        p_amount,
        'COMPLETED',
        p_description
    );
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Transfer completed successfully');
    DBMS_OUTPUT.PUT_LINE('From Account: ' || p_from_account_id || ', Amount: ' || p_amount);
    DBMS_OUTPUT.PUT_LINE('To Account: ' || p_to_account_id);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20004, 'Account not found');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Procedure for depositing money
CREATE OR REPLACE PROCEDURE deposit_money(
    p_to_account_id NUMBER,
    p_amount NUMBER,
    p_description VARCHAR2 DEFAULT NULL
) AS
    v_status VARCHAR2(10);
BEGIN
    -- Check account status
    SELECT status INTO v_status
    FROM accounts
    WHERE account_id = p_to_account_id;
    
    IF v_status != 'ACTIVE' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Account is not active');
    END IF;
    
    -- Update account balance
    UPDATE accounts 
    SET balance = balance + p_amount,
        last_updated = SYSDATE
    WHERE account_id = p_to_account_id;
    
    -- Create transaction record
    INSERT INTO transactions (
        from_account_id,
        to_account_id,
        transaction_type,
        amount,
        status,
        description
    )
    VALUES (
        NULL,
        p_to_account_id,
        'DEPOSIT',
        p_amount,
        'COMPLETED',
        p_description
    );
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Deposit completed successfully');
    DBMS_OUTPUT.PUT_LINE('Account: ' || p_to_account_id || ', Amount: ' || p_amount);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, 'Account not found');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Procedure for withdrawing money
CREATE OR REPLACE PROCEDURE withdraw_money(
    p_from_account_id NUMBER,
    p_amount NUMBER,
    p_description VARCHAR2 DEFAULT NULL
) AS
    v_balance NUMBER;
    v_status VARCHAR2(10);
BEGIN
    -- Check and lock account
    SELECT balance, status INTO v_balance, v_status
    FROM accounts
    WHERE account_id = p_from_account_id
    FOR UPDATE;
    
    IF v_status != 'ACTIVE' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Account is not active');
    END IF;
    
    IF v_balance < p_amount THEN
        RAISE_APPLICATION_ERROR(-20002, 'Insufficient balance. Current balance: ' || v_balance);
    END IF;
    
    -- Update account balance
    UPDATE accounts
    SET balance = balance - p_amount,
        last_updated = SYSDATE
    WHERE account_id = p_from_account_id;
    
    -- Create transaction record
    INSERT INTO transactions (
        from_account_id,
        to_account_id,
        transaction_type,
        amount,
        status,
        description
    )
    VALUES (
        p_from_account_id,
        NULL,
        'WITHDRAWAL',
        p_amount,
        'COMPLETED',
        p_description
    );
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Withdrawal completed successfully');
    DBMS_OUTPUT.PUT_LINE('Account: ' || p_from_account_id || ', Amount: ' || p_amount);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20003, 'Account not found');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

-- Function to get account balance
CREATE OR REPLACE FUNCTION get_account_balance(
    p_account_id NUMBER
) RETURN NUMBER AS
    v_balance NUMBER;
BEGIN
    SELECT balance INTO v_balance
    FROM accounts
    WHERE account_id = p_account_id;
    
    RETURN v_balance;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END;
/

-- View for account summary
CREATE OR REPLACE VIEW account_summary AS
SELECT 
    a.account_id,
    a.account_number,
    a.user_id,
    u.username,
    u.full_name,
    a.account_type,
    a.balance,
    a.currency,
    a.region,
    a.status,
    COUNT(t.transaction_id) AS transaction_count,
    MAX(t.transaction_date) AS last_transaction_date
FROM accounts a
JOIN users u ON a.user_id = u.user_id
LEFT JOIN transactions t ON a.account_id = t.from_account_id OR a.account_id = t.to_account_id
GROUP BY a.account_id, a.account_number, a.user_id, u.username, u.full_name,
         a.account_type, a.balance, a.currency, a.region, a.status;

PROMPT ====================================
PROMPT Procedures created successfully!
PROMPT ====================================
PROMPT
PROMPT Procedures:
PROMPT   - get_user_shard: Determine shard location based on user_id (routing function)
PROMPT   - create_user: Create new user (user_id auto-generated based on region, routed to correct shard)
PROMPT   - create_account: Create new account (co-located with user on same shard via user_id)
PROMPT   - transfer_money: Transfer between accounts (handles cross-shard)
PROMPT   - deposit_money: Deposit to account
PROMPT   - withdraw_money: Withdraw from account
PROMPT   - get_account_balance: Get account balance
PROMPT
PROMPT Routing Rules:
PROMPT   - Users: Sharded by user_id ranges (NA: 1-10M→Shard1, EU: 10M-20M→Shard2, APAC: 20M-30M→Shard3)
PROMPT   - Accounts: Co-located with users (routing follows user_id, not account_id)
PROMPT   - Transactions: Co-located with source account (routing follows from_account_id→user_id)
PROMPT ====================================

