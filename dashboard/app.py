#!/usr/bin/env python3
"""
Oracle Database Dashboard API
Provides REST API endpoints for dashboard statistics and data insertion
"""

from flask import Flask, jsonify, request, render_template
from flask_cors import CORS
import os
from utils import get_db_connection, get_user_region, get_account_region, get_account_info_by_number, get_account_id_by_number, cursor_to_dict, cursor_to_dicts

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

@app.route('/')
def index():
    """Serve the dashboard HTML page"""
    return render_template('dashboard.html')

@app.route('/api/stats/regional', methods=['GET'])
def get_regional_stats():
    """Get statistics by region"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM dashboard_regional_stats")
        results = cursor_to_dicts(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/stats/overall', methods=['GET'])
def get_overall_stats():
    """Get overall statistics"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed', 'details': 'Check database is running and connection settings'}), 500
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM dashboard_overall_stats")
        result = cursor_to_dict(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(result)
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error in get_overall_stats: {error_details}")
        return jsonify({'error': str(e), 'details': error_details}), 500

@app.route('/api/transactions/recent', methods=['GET'])
def get_recent_transactions():
    """Get recent transactions"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM dashboard_recent_transactions")
        results = cursor_to_dicts(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts/by-region', methods=['GET'])
def get_accounts_by_region():
    """Get accounts breakdown by region"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM dashboard_accounts_by_region")
        results = cursor_to_dicts(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/transactions/by-date', methods=['GET'])
def get_transactions_by_date():
    """Get transaction volume by date"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM dashboard_transactions_by_date")
        results = cursor_to_dicts(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/insert/user', methods=['POST'])
def insert_user():
    """Insert a new user"""
    try:
        data = request.json
        region = data.get('region', 'NA').upper()
        
        # Validate region
        if region not in ['NA', 'EU', 'APAC']:
            return jsonify({'error': f'Invalid region: {region}. Must be NA, EU, or APAC'}), 400
        
        # Connect to the appropriate shard based on region
        conn = get_db_connection(shard_region=region)
        if not conn:
            return jsonify({'error': f'Database connection failed to shard for region {region}'}), 500
        
        cursor = conn.cursor()
        
        # Note: user_id is auto-generated by trigger based on region
        cursor.execute("""
            INSERT INTO users (username, email, full_name, phone, address, region)
            VALUES (:username, :email, :full_name, :phone, :address, :region)
        """, {
            'username': data.get('username'),
            'email': data.get('email'),
            'full_name': data.get('full_name'),
            'phone': data.get('phone', None),
            'address': data.get('address', None),
            'region': region
        })
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({'success': True, 'message': 'User inserted successfully'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/insert/account', methods=['POST'])
def insert_account():
    """Insert a new account"""
    try:
        data = request.json
        user_id = data.get('user_id')
        
        if not user_id:
            return jsonify({'error': 'user_id is required'}), 400
        
        # Look up user's region from catalog (user_id is globally unique)
        region = get_user_region(user_id)
        if not region:
            return jsonify({'error': f'User with user_id {user_id} not found'}), 404
        
        # Connect to the appropriate shard based on user's region
        shard_conn = get_db_connection(shard_region=region)
        if not shard_conn:
            return jsonify({'error': f'Database connection failed to shard for region {region}'}), 500
        
        cursor = shard_conn.cursor()
        
        # Note: account_id is auto-generated, region should match user's region
        # Currency is always USD (enforced by constraint and trigger)
        cursor.execute("""
            INSERT INTO accounts (user_id, account_number, account_type, balance, currency, region)
            VALUES (:user_id, :account_number, :account_type, :balance, :currency, :region)
        """, {
            'user_id': user_id,
            'account_number': data.get('account_number'),
            'account_type': data.get('account_type'),
            'balance': data.get('balance', 0),
            'currency': 'USD',  # Always USD (enforced by constraint and trigger)
            'region': region
        })
        
        shard_conn.commit()
        cursor.close()
        shard_conn.close()
        
        return jsonify({'success': True, 'message': 'Account inserted successfully'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/insert/transaction', methods=['POST'])
def insert_transaction():
    """Insert a new transaction"""
    conn = None
    try:
        data = request.json
        print(f"Received transaction data: {data}")  # Debug log
        
        # Validate and clean data
        transaction_type = data.get('transaction_type')
        # Only use account_number (account_id is not globally unique across shards)
        from_account_number = data.get('from_account_number')
        to_account_number = data.get('to_account_number')
        amount = data.get('amount')
        
        from_account_info = None
        to_account_info = None
        
        # Look up account info by account_number (required method)
        # account_id is NOT globally unique across shards, so we MUST use account_number
        if from_account_number:
            from_account_info = get_account_info_by_number(from_account_number)
            if not from_account_info:
                return jsonify({'error': f'Account with number {from_account_number} not found'}), 404
        else:
            from_account_info = None
            
        if to_account_number:
            to_account_info = get_account_info_by_number(to_account_number)
            if not to_account_info:
                return jsonify({'error': f'Account with number {to_account_number} not found'}), 404
        else:
            to_account_info = None
            
        if amount:
            amount = float(amount)
        
        # Validate required fields based on transaction type
        if transaction_type == 'TRANSFER':
            # For transfers, we MUST have account numbers to uniquely identify accounts
            if not from_account_number or not to_account_number:
                return jsonify({'error': 'Transfer requires both from_account_number and to_account_number. Account IDs are not globally unique across shards.'}), 400
            if not from_account_info or not to_account_info:
                return jsonify({'error': 'Could not find account information. Please ensure account numbers are correct.'}), 404
            if from_account_number == to_account_number:
                return jsonify({'error': 'Cannot transfer to the same account'}), 400
            # Transactions are stored on the source account's shard
            # Connect to the from_account's shard
            region = from_account_info['region']
            print(f"Transfer: from_account {from_account_number} (region={region}) to to_account {to_account_number}")
        elif transaction_type == 'DEPOSIT':
            # For deposits, we MUST have account_number to uniquely identify the account
            if not to_account_number:
                return jsonify({'error': 'Deposit requires to_account_number. Account IDs are not globally unique across shards.'}), 400
            if not to_account_info:
                return jsonify({'error': f'Account with number {to_account_number} not found'}), 404
            region = to_account_info['region']
            print(f"Deposit: to_account {to_account_number} (region={region})")
        elif transaction_type == 'WITHDRAWAL':
            # For withdrawals, we MUST have account_number to uniquely identify the account
            if not from_account_number:
                return jsonify({'error': 'Withdrawal requires from_account_number. Account IDs are not globally unique across shards.'}), 400
            if not from_account_info:
                return jsonify({'error': f'Account with number {from_account_number} not found'}), 404
            region = from_account_info['region']
            print(f"Withdrawal: from_account {from_account_number} (region={region})")
        else:
            return jsonify({'error': f'Invalid transaction type: {transaction_type}'}), 400
        
        # Connect to the appropriate shard based on account's region
        conn = get_db_connection(shard_region=region)
        if not conn:
            return jsonify({'error': f'Database connection failed to shard for region {region}'}), 500
        
        cursor = conn.cursor()
        
        # Use stored procedures for all transaction types (handle balance updates automatically)
        # Procedures now use account_number (globally unique) instead of account_id
        try:
            if transaction_type == 'TRANSFER' and from_account_number and to_account_number:
                print(f"Calling transfer_money procedure: from={from_account_number}, to={to_account_number}, amount={amount}")
                cursor.callproc('transfer_money', [
                    from_account_number,
                    to_account_number,
                    amount,
                    data.get('description', '')
                ])
                conn.commit()
                cursor.close()
                conn.close()
                return jsonify({'success': True, 'message': 'Transfer completed successfully'})
            elif transaction_type == 'DEPOSIT' and to_account_number:
                print(f"Calling deposit_money procedure: to={to_account_number}, amount={amount}")
                cursor.callproc('deposit_money', [
                    to_account_number,
                    amount,
                    data.get('description', '')
                ])
                conn.commit()
                cursor.close()
                conn.close()
                return jsonify({'success': True, 'message': 'Deposit completed successfully'})
            elif transaction_type == 'WITHDRAWAL' and from_account_number:
                print(f"Calling withdraw_money procedure: from={from_account_number}, amount={amount}")
                cursor.callproc('withdraw_money', [
                    from_account_number,
                    amount,
                    data.get('description', '')
                ])
                conn.commit()
                cursor.close()
                conn.close()
                return jsonify({'success': True, 'message': 'Withdrawal completed successfully'})
            else:
                # Fallback for other transaction types or invalid combinations
                cursor.execute("""
                    INSERT INTO transactions (from_account_number, to_account_number, transaction_type, amount, status, description)
                    VALUES (:from_account_number, :to_account_number, :transaction_type, :amount, :status, :description)
                """, {
                    'from_account_number': from_account_number,
                    'to_account_number': to_account_number,
                    'transaction_type': transaction_type,
                    'amount': amount,
                    'status': data.get('status', 'COMPLETED'),
                    'description': data.get('description', '')
                })
                conn.commit()
                cursor.close()
                conn.close()
                return jsonify({'success': True, 'message': 'Transaction inserted successfully'})
        except Exception as proc_error:
            conn.rollback()
            print(f"Transaction procedure error: {proc_error}")
            error_msg = str(proc_error)
            # Extract error message if it's an Oracle error
            if hasattr(proc_error, 'args') and proc_error.args:
                error_msg = str(proc_error.args[0])
            cursor.close()
            conn.close()
            return jsonify({'error': f'Transaction failed: {error_msg}'}), 500
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error in insert_transaction: {error_details}")
        if conn:
            try:
                conn.rollback()
                conn.close()
            except:
                pass
        return jsonify({'error': str(e), 'details': error_details}), 500

@app.route('/api/users', methods=['GET'])
def get_users():
    """Get all users for dropdown"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        # Use users_all view which unions data from all shards via catalog
        # user_id is globally unique (ranges: NA=1-10M, EU=10M+1-20M, APAC=20M+1-30M)
        cursor.execute("SELECT user_id, username, full_name, region FROM users_all ORDER BY username")
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'user_id': row[0],
                'username': row[1],
                'full_name': row[2],
                'region': row[3]
            })
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """Get all accounts for dropdown or list"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        # Get accounts with user information for the list view
        # user_id is globally unique, account_id removed (not globally unique)
        cursor.execute("""
            SELECT 
                a.account_number,
                a.user_id,
                a.account_type,
                a.balance,
                a.currency,
                a.region,
                a.status,
                a.created_date,
                u.username,
                u.full_name
            FROM accounts_all a
            LEFT JOIN users_all u ON a.user_id = u.user_id AND a.shard_location = u.shard_location
            ORDER BY a.account_number
        """)
        results = cursor_to_dicts(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        import traceback
        print(f"Error in get_accounts: {traceback.format_exc()}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/list', methods=['GET'])
def get_users_list():
    """Get all users with full details for list view"""
    conn = get_db_connection()
    if not conn:
        return jsonify({'error': 'Database connection failed'}), 500
    
    try:
        cursor = conn.cursor()
        # Use union views which combine data from all shards via catalog
        # user_id is globally unique (ranges: NA=1-10M, EU=10M+1-20M, APAC=20M+1-30M)
        cursor.execute("""
            SELECT 
                u.user_id,
                u.username,
                u.email,
                u.full_name,
                u.phone,
                u.address,
                u.region,
                u.created_date,
                COUNT(DISTINCT a.account_number) AS account_count,  -- Use account_number (globally unique)
                COALESCE(SUM(a.balance), 0) AS total_balance
            FROM users_all u
            LEFT JOIN accounts_all a ON u.user_id = a.user_id AND u.shard_location = a.shard_location
            GROUP BY u.user_id, u.username, u.email, u.full_name, u.phone, u.address, u.region, u.created_date
            ORDER BY u.user_id
        """)
        results = cursor_to_dicts(cursor)
        
        cursor.close()
        conn.close()
        
        return jsonify(results)
    except Exception as e:
        import traceback
        print(f"Error in get_users_list: {traceback.format_exc()}")
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    # Use port 5001 to avoid macOS AirPlay conflict on port 5000
    port = int(os.getenv('PORT', 5001))
    print(f"\nðŸš€ Starting Dashboard Server on http://localhost:{port}")
    print(f"ðŸ“Š Dashboard will be available at: http://localhost:{port}")
    print(f"ðŸ”— API endpoints available at: http://localhost:{port}/api/...\n")
    
    app.run(host='0.0.0.0', port=port, debug=True)

